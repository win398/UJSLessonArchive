# 张承楷的学习日志

## 一、学习内容

### 1.1AODV协议的基本含义

AODV协议，全称无线自组网按需平面距离向量路由协议，能够实现单播和多播路由。

不同于其他的一些路由协议，AODV是当源节点向目的节点发送封包时，原节点才在网络中发起路由查找过程，找到相应的路由，这就是说一个网络节点要建立连接时才广播一个连接建立的请求。而其他的AODV节点转发这个请求消息，并记录源节点，和回到源节点的临时路由。

因此，AODV有以下特征：

1. 反应式路由协议，需要时才生成路由表
2. 平时网络为静态

### 1.2 AODV协议过程

#### 1.2.1 AODV的帧格式

 1：RREQ：路由请求帧

当源节点需要向目的节点发送数据包，但又没有目的节点的路由入口时，才会发送路由广播帧RREQ。当RREQ在网络中传播时，中间节点会更新各自到源节点的路由，称为反向路由。RREQ请求帧中包含源节点以前记录的到目的节点的序列号。

  2：RREP：路由应答帧

当RREQ到达目的节点时，目的节点通过向该反向路由发送RREP应答帧，从而在该条路径的各个节点建立通向目的节点的前向路由。且当RREP传播到源节点时，中间节点根据该RREP更新他们各自指向目的节点的路由信息。节点只对第一次收到的RREQ发送RREP应答帧

  3：RERR：路由错误帧

一个节点检测到邻居节点不可达时广播RERR路由错误帧，发送方式有：单播、重复单播、及广播。

  4：HELLO：活跃路由链路检测帧

Hello消息帧用于检测活跃路径上相邻节点的链接状况

#### 1.2.2 AODV路由全过程

广播RREQ路由请求帧，中间节点更新各自到源节点的路由表，如果收到RREQ的节点不是目的节点，并且没有到达目的节点的更新的有效路由，则转发该RREQ,中间节点维护指向路由源节点的反向路由。 源节点将RREQ的序列号、ID字段加1，将源节点的IP，序列号、目的节点的IP、序列号等信息添加到RREQ中，广播至网络，中间节点将RREQ中的目的节点序列号至当前最大，跳数字段加1，然后转发，目的节点序列号加1产生RREP应答帧，单播发送至源节点。

而路由维护则使用HELLO帧，用于检测活跃路径上相邻节点的链接状况，且依赖网络中每个节点维护自身的序列号。通过比较来自目的节点路由控制帧中的序列号SN1和本节点维护的目的节点的序列号SN2，就可以确定本链路的新旧程度。如果SN2-SN1<0(有符号数相减)，说明路由表中的维护信息已过时，应将路由信息更新至路由控制帧最新的路由信息。

#### 1.2.3 ns3中的AODV协议

 在ns3中，通过AODVHelper建立AODV路由，AODVHelper继承了IPV4RoutingHelper，其在ns3中的拓扑图如下所示：

![image-20200726085832955](https://raw.githubusercontent.com/zcker/githubPicture/master/20200726085833.png)

可以看到AODVHelper继承了对象工厂，并通过各个类设置了不同的属性。

AODVHelper主要分为以下函数：

1.copy()

返回AODVHelper的复制指针,拓扑图如下：

![image-20200726090459396](https://raw.githubusercontent.com/zcker/githubPicture/master/20200726090459.png)

可以看到，copy函数依赖AODVHelper，但实现复制主要通过其余的helper来实现。

2.create()

在实例中，通过下面的语句调用函数

``` C++
  AodvHelper aodv;
  // you can configure AODV attributes here using aodv.Set(name, value)
  InternetStackHelper stack;
  stack.SetRoutingHelper (aodv); // has effect on the next Install ()
  stack.Install (nodes);
```

在stack.SetRoutingHelper (aodv)这句语句中，调用了create()函数，返回一个路由协议。

## 二、学习心得

在AODV实例的学习中，我加深了对NS3的了解，也对于AODV及其余网络协议加深了了解，对于Deepin这类Linux的虚拟机也更加熟悉。